if (getCookie("id") === "" || getCookie("id") === "0" || isEmpty(history.state.param.id)) {
    location.href = "index.html";
} else {

    /**
     * Limpa dados locais
     */
    if (typeof ID === "undefined") {
        var ID = history.state.param.id;
    } else {
        dbLocal.clear("crises");
        dbLocal.clear("sintomas");
        dbLocal.clear("medicamentos");
        dbLocal.clear("atividade-fisica");
        dbLocal.clear("sono");
        dbLocal.clear("humor");
        ID = history.state.param.id;
    }

    /**
     * Verifica definições iniciais se já foram declaradas
     */
    if (typeof chartFilter === "undefined") {
        var chartFilter = {dateStart: null, dateEnd: null, interval: 'month', indicadores: []};

        var tpl = {};
        var lang = {};
        var promessas = [];
        promessas.push(readPaciente(ID));
        promessas.push(getJSON('public/language/' + LANG + '/graficos.json'));
        promessas.push(getRequest('public/tpl/graficoCrisesCalendar.mustache'));
        promessas.push(getRequest('public/tpl/graficoCrisesIntensidade.mustache'));
        promessas.push(getRequest('public/tpl/graficoCrisesComentarios.mustache'));
        promessas.push(getRequest('public/tpl/graficoHeader.mustache'));
        promessas.push(getRequest('public/tpl/graficoHumor.mustache'));
        promessas.push(getRequest('public/tpl/graficoHumor2.mustache'));
        promessas.push(getRequest('public/tpl/graficoSono.mustache'));
        promessas.push(getRequest('public/tpl/graficoArrowBack.mustache'));
        promessas.push(getRequest('public/tpl/graficoArrowForward.mustache'));
        promessas.push(getRequest('public/tpl/pacienteGraficoEmpty.mustache'));
        promessas.push(getRequest('public/tpl/graficoHeaderSubtitle.mustache'));

        var modChart = {};
        var readIndicador = {};
        var all = Promise.all(promessas).then(r => {
            paciente = r[0];
            lang = r[1];
            tpl = {
                graficoCrisesCalendar: r[2],
                graficoCrisesIntensidade: r[3],
                graficoCrisesComentarios: r[4],
                graficoHeader: r[5],
                graficoHumor: r[6],
                graficoHumor2: r[7],
                graficoSono: r[8],
                graficoArrowBack: r[9],
                graficoArrowForward: r[10],
                pacienteGraficoEmpty: r[11],
                graficoHeaderSubtitle: r[12]
            };
        });
        var draw = Chart.controllers.pie.prototype.draw;
        Chart.controllers.pie = Chart.controllers.pie.extend({
            draw: function () {
                draw.apply(this, arguments);
                let ctx = this.chart.chart.ctx;
                let _fill = ctx.fill;
                ctx.fill = function () {
                    ctx.save();
                    ctx.shadowColor = 'rgba(45,146,203,0.53)';
                    ctx.shadowBlur = 20;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    _fill.apply(this, arguments)
                    ctx.restore()
                }
            }
        });
        Date.prototype.addDays = function (days) {
            var date = new Date(this.valueOf());
            date.setDate(date.getDate() + days);
            return date
        }
    } else {
        chartFilter = {dateStart: null, dateEnd: null, interval: 'month', indicadores: []};
        modChart = {};
        readIndicador = {};
        all = readPaciente(ID).then(r => {
            paciente = r
        })
    }

    /**
     * Começa o calendário com o últimos 30 dias
     */
    function startCalendar() {
        let now = new Date();
        let day = ("0" + now.getDate()).slice(-2);
        let month = ("0" + (now.getMonth() + 1)).slice(-2);
        let today = now.getFullYear() + "-" + (month) + "-" + (day);
        let old = new Date(new Date().setDate(new Date().getDate() - 30));
        let Oldday = ("0" + old.getDate()).slice(-2);
        let Oldmonth = ("0" + (old.getMonth() + 1)).slice(-2);
        let lastMonth = old.getFullYear() + "-" + (Oldmonth) + "-" + (Oldday);
        $("#date-start").val(lastMonth).trigger("change");
        $("#date-end").val(today).trigger("change");

        //Fixa dia específico para iniciar o gráfico
        // $("#date-start").val("2019-11-01").trigger("change");
        // $("#date-end").val("2019-11-30").trigger("change");
    }

    function getDayOfWeek(date) {
        var dayOfWeek = new Date(date).getDay();
        return isNaN(dayOfWeek) ? null : ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sab'][dayOfWeek]
    }

    function getDayofMonth(date) {
        var dayOfMonth = new Date(date).getMonth();
        return isNaN(dayOfMonth) ? null : ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'][dayOfMonth]
    }

    function getXvalue(fieldX) {
        let dateCheck = new RegExp("^\\d{4}-\\d{2}-\\d{2}(\\s\\d{2}:\\d{2}:\\d{2})*$", "i");
        let x = fieldX;
        if (dateCheck.test(fieldX)) {
            let d = fieldX.split("-");
            if (chartFilter.interval === "year") {
                x = getDayofMonth(fieldX)
            } else if (chartFilter.interval === "month") {
                x = zeroEsquerda(parseInt(d[2]))
            } else if (chartFilter.interval === "week") {
                x = getDayOfWeek(fieldX)
            } else {
                x = zeroEsquerda(parseInt(d[2]))
            }
        }
        return x
    }

    function roundStep(number, increment) {
        increment = increment || 1;
        return Math.round((number - increment) / increment) * increment + increment
    }

    /**
     * Obtém os dados para o gráfico considerando gráficos X por Y
     * @param chart
     * @returns {{}}
     */
    function privateChartGetDataMakerXY(chart) {
        let dadosTabela = {};
        let count = {};
        let dateHistoryRegister = [];

        $.each(chart.data, function (i, e) {
            let x = e[chart.fieldX];
            let y = e[chart.fieldY];
            let xOriginal = x;

            if (chartFilter.interval === "year" && chart.fieldDate) {
                let xx = x.split('-');
                x = xx[0] + "-" + xx[1] + "-15";

            } else if (chartFilter.interval === "day" && chart.fieldDate) {

                /**
                 * Se for filtro Dia e tiver data, então converte a label do eixo X em número de registros
                 */
                chart.functionLabelX = x => {
                    return  (parseInt(x) + 1) + lang.graficoRegistroOrdem;
                };

                let dateCheck = new RegExp("^\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$", "i");
                if (!dateCheck.test(x))
                    x += " " + zeroEsquerda(i) + ":00"
            }

            if (typeof y !== "undefined" && y !== null && y !== "") {
                if (!isNaN(y)) {
                    if (chart.operacao === "sum" || chart.operacao === "media") {
                        dadosTabela[x] = typeof dadosTabela[x] === "undefined" ? y : dadosTabela[x] + y;
                        if (chart.operacao === "media" && (chartFilter.interval !== "year" || dateHistoryRegister.indexOf(xOriginal) === -1)) {
                            count[x] = (typeof count[x] === "undefined" ? 1 : count[x] + 1);
                            dateHistoryRegister.push(xOriginal);
                        }
                    } else {
                        if (typeof dadosTabela[x] === "undefined")
                            dadosTabela[x] = [];
                        if (chart.operacao === "maioria") {
                            dadosTabela[x][y] = (typeof dadosTabela[x][y] === "undefined" ? 1 : dadosTabela[x][y] + 1);
                            if (typeof count[x] === "undefined")
                                count[x] = [];
                            count[x][chart.fieldY] = (typeof count[x][chart.fieldY] === "undefined" ? 1 : count[x][chart.fieldY] + 1)
                        } else {
                            dadosTabela[x].push(y)
                        }
                    }
                } else if (typeof y !== "number") {
                    if (typeof dadosTabela[x] === "undefined" || dadosTabela[x].constructor !== Array)
                        dadosTabela[x] = [];

                    dadosTabela[x].push(y)
                }
            }
        });
        for (let x in dadosTabela) {
            if (chart.operacao === "media") {
                dadosTabela[x] = (chart.roundValueStepY ? roundStep(dadosTabela[x] / count[x], chart.stepY) : dadosTabela[x] / count[x])
            } else if (chart.operacao === "maioria") {
                let maioria = {y: "", valor: -1};
                for (let y in dadosTabela[x]) {
                    if (dadosTabela[x][y] > maioria.valor)
                        maioria = {y: y, valor: dadosTabela[x][y]}
                }
                dadosTabela[x] = (chart.roundValueStepY ? roundStep(maioria.y, chart.stepY) : maioria.y)
            } else {
                dadosTabela[x] = (chart.roundValueStepY ? roundStep(dadosTabela[x], chart.stepY) : dadosTabela[x])
            }
        }
        return dadosTabela
    }

    /**
     * Obtém os dados para o gráfico considerando uma lista de X por Y
     * @param chart
     * @returns {[]}
     */
    function privateChartGetDataMakerXYMult(chart) {
        let dadosTabela = [];
        $.each(chart.data, function (i, e) {
            $.each(chart.fieldY, function (ii, y) {
                if (typeof e[y] !== "undefined" && !isNaN(e[y])) {
                    if (typeof dadosTabela[e[chart.fieldX]] === "undefined") {
                        dadosTabela[e[chart.fieldX]] = [];
                        dadosTabela[e[chart.fieldX]][y] = 0
                    } else if (typeof dadosTabela[e[chart.fieldX]][y] === "undefined") {
                        dadosTabela[e[chart.fieldX]][y] = 0
                    }
                    dadosTabela[e[chart.fieldX]][y] += e[y]
                }
            })
        })
        return dadosTabela
    }

    function privateChartGetDataMakerY(chart) {
        let dadosTabela = [];
        let dd = [];
        $.each(chart.data, function (i, e) {
            let y = chart.functionValueY(chart.roundValueStepY ? roundStep(e[chart.fieldY], chart.stepY) : e[chart.fieldY]);
            if (typeof dd[y] === "undefined")
                dd[y] = 0;
            dd[y]++
        });
        let ddd = [];
        for (let x in dd)
            ddd.push({x: x, y: dd[x]});
        ddd = chartDataOrder(ddd, "x").reverse();
        for (let x in ddd) {
            chart.labels.push(ddd[x].x);
            chart.backgroundColor.push(chart.functionColor(ddd[x].x));
            dadosTabela.push(ddd[x].y)
        }
        return dadosTabela
    }

    function privateChartGetDataMakerYMult(chart) {
        let dadosTabela = [];
        $.each(chart.data, function (i, e) {
            $.each(chart.fieldY, function (ii, y) {
                if (typeof e[y] !== "undefined" && !isNaN(e[y])) {
                    if (typeof dadosTabela[y] === "undefined")
                        dadosTabela[y] = 0;
                    dadosTabela[y] += e[y]
                }
            })
        });
        return dadosTabela
    }

    function privateChartGetWeeks() {
        return ["dom", "seg", "ter", "qua", "qui", "sex", "sab"]
    }

    function privateChartGetMonths() {
        return ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"]
    }

    function privateChartGetNumberDaysMonth(month) {
        if (month === 1)
            return 28;
        if ([3, 5, 8, 10].indexOf(month) > -1)
            return 30;
        return 31
    }

    function getDates(startDate, stopDate) {
        startDate = new Date(startDate + " 23:59:59");
        stopDate = new Date(stopDate + " 23:59:59");
        var dateArray = new Array();
        var currentDate = startDate;
        while (currentDate <= stopDate) {
            dateArray.push(new Date(currentDate));
            currentDate = currentDate.addDays(1)
        }
        return dateArray
    }

    function privateChartGetLabelsDate() {
        if (chartFilter.interval === "week")
            return ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sab']; else if (chartFilter.interval === "month")
            return ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31']; else if (chartFilter.interval === "year")
            return ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez']; else return ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24']
    }

    function privateChartGetIntervalDate() {
        let intervalo = [];
        let dateAtual = chartFilter.dateStart;
        while (dateAtual <= chartFilter.dateEnd) {
            intervalo.push(dateAtual);
            let now = new Date(dateAtual + " 23:59:59");
            let dateLimit = new Date(now.setDate(now.getDate() + 1));
            dateAtual = dateLimit.getFullYear() + "-" + zeroEsquerda(dateLimit.getMonth() + 1) + "-" + zeroEsquerda(dateLimit.getDate())
        }
        return intervalo
    }

    function privateChartGetDataMaker(chart) {
        if (typeof chart.fieldY === "undefined" || chart.fieldY === null || isEmpty(chart.fieldY)) {
            toast("Gráfico não pode ser gerado! Coluna Y não informada", 7000, "toast-warning");
            return []
        }
        if (typeof chart.fieldX !== "undefined" || typeof chart.fieldDate !== "undefined")
            chart.data = chartDataOrder(chart.data, chart.fieldX || chart.fieldDate);

        if (chart.fieldDate) {
            let dd = [];
            $.each(chart.data, function (i, e) {
                if ((!isEmpty(chartFilter.dateStart) && chartFilter.dateStart !== "NaN-aN-aN" && e[chart.fieldDate] >= chartFilter.dateStart) && (!isEmpty(chartFilter.dateEnd) && chartFilter.dateEnd !== "NaN-aN-aN" && e[chart.fieldDate] <= chartFilter.dateEnd))
                    dd.push(e)
            });
            chart.data = dd.reverse();
            delete dd

        } else {
            chart.data = chart.data.reverse()
        }

        let dadosTabela = [];
        if (typeof chart.fieldX === "undefined" || chart.fieldX === null || chart.fieldX === "" || chart.fieldX === "null") {

            /**
             * Obtém dados quantitativos, que não comparam com outro campo
             * Somente Y
             */
            if (chart.fieldY.constructor === Array) {
                dadosTabela = privateChartGetDataMakerYMult(chart)
            } else if (typeof chart.fieldY === "string") {
                dadosTabela = privateChartGetDataMakerY(chart)
            }
        } else {

            /**
             * Obtém os dados brutos para o gráfico comparativo X por Y
             * compara X por Y
             */
            if (chart.fieldY.constructor === Array) {
                dadosTabela = privateChartGetDataMakerXYMult(chart)
            } else if (typeof chart.fieldY === "string") {
                dadosTabela = privateChartGetDataMakerXY(chart)
            }

            if (!isEmpty(dadosTabela)) {

                /**
                 * Se for gráficos que possuem data no campo X
                 * então preenche as lacunas de dados vazios com
                 * valor nulo para completar os dados da gráfico
                 */
                if (chart.fieldDate) {
                    if (chartFilter.interval === "week" || chartFilter.interval === "month") {
                        $.each(getDates(chartFilter.dateStart, chartFilter.dateEnd), function (i, date) {
                            let dateNow = date.getFullYear() + "-" + zeroEsquerda(date.getMonth() + 1) + "-" + zeroEsquerda(date.getDate());
                            if (typeof dadosTabela[dateNow] === "undefined") {
                                if (chart.operacao === "sum" || chart.operacao === "media" || chart.operacao === "maioria")
                                    dadosTabela[dateNow] = null;
                                else
                                    dadosTabela[dateNow] = []
                            }
                        })
                    } else if (chartFilter.interval === "year") {
                        let year = chartFilter.dateStart.split("-")[0];
                        for (let i = 1; i < 13; i++) {
                            let dateNow = year + "-" + zeroEsquerda(i) + "-15";
                            if (typeof dadosTabela[dateNow] === "undefined") {
                                if (chart.operacao === "sum" || chart.operacao === "media" || chart.operacao === "maioria")
                                    dadosTabela[dateNow] = null;
                                else
                                    dadosTabela[dateNow] = []
                            }
                        }
                    }
                }

                let dataResult = [];
                let convertIndex = 1;
                let convertStringToNumber = [];
                let labelYString = [];
                let isStringYLabel = !1;
                let bigger = -999999;
                let smaller = 99999999999;

                /**
                 * Se Y for string, converte para número para poder
                 * construir o gráfico e faz a associação do número gerado
                 * com a string original.
                 *
                 * Obtém o maior e o menor valor do gráfico
                 */
                for (let x in dadosTabela) {
                    let y = chart.functionValueY(dadosTabela[x]);
                    if (isEmpty(y)) {
                        dataResult.push({x: chart.functionValueX(x), y: "", v: "", r: 0})
                    } else {
                        if (chart.operacao === "registros") {
                            let dd = [];
                            $.each(y, function (i, v) {
                                if (typeof dd[v] === "undefined")
                                    dd[v] = 1;
                                else
                                    dd[v]++
                            });
                            for (let n in dd) {
                                if (isNaN(n)) {
                                    isStringYLabel = !0;
                                    if (typeof convertStringToNumber[n] === "undefined") {
                                        if (chart.order && typeof chart.order === "object") {
                                            if (chart.order.indexOf(n) > -1) {
                                                labelYString[chart.order.indexOf(n) + 1] = n;
                                                convertStringToNumber[n] = chart.order.indexOf(n) + 1
                                            } else {
                                                continue
                                            }
                                        } else {
                                            labelYString[convertIndex] = n;
                                            convertStringToNumber[n] = convertIndex++
                                        }
                                    }
                                }
                                if (bigger < dd[n])
                                    bigger = dd[n];
                                if (smaller > dd[n])
                                    smaller = dd[n];

                                // without bubble calculate
                                // dataResult.push({x: chart.functionValueX(x), y: convertStringToNumber[n], v: 1, r: 1});

                                // with Bubble calculate size
                                dataResult.push({
                                    x: chart.functionValueX(x),
                                    y: convertStringToNumber[n],
                                    v: dd[n],
                                    r: dd[n]
                                });
                            }
                        } else {
                            dataResult.push({x: chart.functionValueX(x), y: y})
                        }
                    }
                    chart.labels.push(chart.functionValueX(x))
                }

                /**
                 * Calcula o r, nos casos de gráficos bubble que
                 * possuem tamanhos diferentes que representam quantidade
                 */
                let min = 6;
                let max = 10;
                $.each(dataResult, function (i, e) {
                    if (dataResult[i].r > 0)
                        dataResult[i].r = ((dataResult[i].r * (max - min)) / bigger) + min;
                });

                /**
                 * Adiciona pré função ao tooltips com a string associada em Y
                 * caso tenha
                 */
                if (isStringYLabel) {
                    chart.stepY = 1;
                    chart.minY = 0;
                    chart.functionAssocLabelY = y => {
                        return labelYString[y]
                    };
                    chart.functionTooltips = (x, y, v) => {
                        return v + " registro" + (v > 1 ? "s" : "")
                    }
                }
                dadosTabela = dataResult
            }
        }

        return dadosTabela
    }

    /**
     * Informa o tipo do gráfico, caso não seja informado, coloca um default
     * não permite informar tipos diferentes dos aceitos
     * @param type
     * @returns {[]}
     */
    function operatorChartSetType(type) {
        let types = [];
        if (typeof type === "string" && ["line", "bar", "radar", "doughnut", "pie", "polarArea", "bubble", "scatter"].indexOf(type) > -1) {
            types.push(type)
        } else if (typeof type === "object" && type !== null && type.constructor === Array && !isEmpty(type)) {
            $.each(type, function (i, t) {
                if (typeof t === "string" && ["line", "bar", "radar", "doughnut", "pie", "polarArea", "bubble", "scatter"].indexOf(t) > -1)
                    types.push(t)
            })
        }
        if (isEmpty(types))
            types.push("bar");
        return types
    }

    /**
     * Gera a base padrão para qualquer gráfico novo,
     * isso inclui dados, tipo de gráfico e funções
     * @param $this
     * @param type
     * @returns {string|*}
     */
    function privateChartGenerateBase($this, type) {
        type = typeof type !== "undefined" ? type : "bar";
        if (isEmpty($this.fieldY)) {
            toast("Gráfico Erro! Data ou campo Y ausente", 7000, "toast-warning");
            return ""
        }
        if (!$this.operacao)
            $this.operacao = "registros";
        if (!$this.functionLabelX) {
            $this.functionLabelX = x => {
                return x
            }
        }
        if (!$this.functionLabelY) {
            $this.functionLabelY = y => {
                return y
            }
        }
        if (!$this.functionAssocLabelY) {
            $this.functionAssocLabelY = y => {
                return y
            }
        }
        if (!$this.functionValueX) {
            $this.functionValueX = x => {
                return x
            }
        }
        if (!$this.functionValueY) {
            $this.functionValueY = y => {
                return y
            }
        }
        $this.paddings = $this.paddings || {top: 30, right: 20, bottom: 30, left: 0};
        $this.functionTooltips = typeof $this.functionTooltips === "function" ? $this.functionTooltips : function (x, y, v) {
            return y
        };
        $this.functionColor = typeof $this.functionColor === "function" ? $this.functionColor : function (c) {
            return (typeof $this.colorBase !== "undefined" && $this.colorBase !== "" ? $this.colorBase : c)
        };
        $this.type = operatorChartSetType(type);
        $this.labels = [];
        $this.backgroundColor = [];
        $this.data = privateChartGetDataMaker($this);
        if ($this.fieldDate)
            $this.data = chartDataOrder($this.data, "x").reverse();
        if ($this.fieldDate && !$this.minX)
            $this.minX = chartFilter.dateStart;
        if ($this.fieldDate && !$this.maxX)
            $this.maxX = chartFilter.dateEnd;

        $this.labels.sort();

        return $this
    }

    /**
     * Gera as opções padrões para todos os gráficos utilizados
     * @param $this
     * @returns {{layout: {padding: null}, tooltips: {callbacks: {title: (function(*, *): {textMargin: number, position: string, render: string, fontColor: string}|{render: string}|HTMLLabelElement|*|{textMargin: number, position: string, render: string, fontColor: string}|{render: string})}}}}
     */
    function privateChartGenerateOptions($this) {
        let options = {
            layout: {padding: $this.paddings}, tooltips: {
                callbacks: {
                    title: function (tooltipItem, data) {
                        return data.labels[tooltipItem[0].index]
                    }
                }
            }
        };
        options.idChart = Date.now() + Math.floor((Math.random() * 10000) + 1);
        options.funcitonImage = (typeof $this.functionImage === "function");
        options.animation = {duration: 500};

        if (["radar", "pie", "doughnut", "polarArea"].indexOf($this.type[0]) > -1) {

            /**
             * Gráficos quantitativos, somente valor em Y
             */
            options.aspectRatio = 3;
            options.tooltips.callbacks.label = function (tooltipItem, data) {
                var dataset = data.datasets[tooltipItem.datasetIndex];
                var meta = dataset._meta[Object.keys(dataset._meta)[0]];
                var total = meta.total;
                var currentValue = dataset.data[tooltipItem.index];
                var percentage = parseFloat((currentValue / total * 100).toFixed(1));
                return ' ' + percentage + '% (' + currentValue + ')'
            };
            options.plugins = {labels: [{render: 'percentage', position: 'outside', fontColor: '#555', textMargin: 7}]};
            for (let i in $this.labels)
                $this.labels[i] = $this.functionLabelY($this.functionAssocLabelY($this.labels[i]));
            options.legend = {position: "left", reverse: !0}
        } else {

            /**
             * Gráficos comparativos, valor em X por Y
             */
            options.plugins = {labels: [{render: 'value',}]};
            $this.backgroundColor = function (context) {
                let value = $this.functionAssocLabelY(context.dataset.data[context.dataIndex].y);
                return $this.functionColor(value)
            };
            options.tooltips.callbacks = {
                title: function (tooltipItem, data) {
                    return $this.title || data.labels[tooltipItem[0].index]
                }, label: function (tooltipItem, data) {
                    var dataset = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                    return ' ' + $this.functionTooltips(dataset.x, $this.functionAssocLabelY(dataset.y), dataset.v)
                }
            };
            options.legend = {display: !1};
            options.responsive = !0;
            options.aspectRatio = 3;
            options.scales = {
                yAxes: [{
                    gridLines: {
                        display: typeof $this.hideLineY === "undefined",
                        color: "#F5F5F5",
                        drawBorder: typeof $this.hideLineX === "undefined",
                        zeroLineWidth: 3,
                        zeroLineColor: "#EEEEEE",
                        offsetGridLines: $this.gridOffsetLineY
                    },
                    ticks: {
                        padding: 15,
                        max: $this.maxY || undefined,
                        min: $this.minY || undefined,
                        beginAtZero: $this.minY == 0,
                        stepSize: $this.stepY || undefined,
                        callback: function (y) {
                            return $this.functionLabelY($this.functionAssocLabelY(y))
                        },
                        display: typeof $this.hideLabelY === "undefined"
                    }
                }],
                xAxes: [{
                    gridLines: {
                        display: typeof $this.hideLineX === "undefined",
                        color: "#F5F5F5",
                        drawBorder: typeof $this.hideLineY === "undefined",
                        zeroLineWidth: 3,
                        zeroLineColor: "#EEEEEE",
                        offsetGridLines: $this.gridOffsetLineX
                    },
                    ticks: {
                        padding: 0,
                        max: $this.maxX || undefined,
                        min: $this.minX || undefined,
                        beginAtZero: $this.minX == 0,
                        source: 'data',
                        autoSkip: !1,
                        stepSize: $this.stepX || undefined,
                        callback: $this.functionLabelX,
                        display: typeof $this.hideLabelX === "undefined"
                    },
                    offset: !0
                }]
            };
            if ($this.fieldDate) {
                options.scales.xAxes[0].type = 'time';
                options.scales.xAxes[0].time = {
                    unit: chartFilter.interval,
                    displayFormats: {'day': 'H', 'week': 'ddd', 'month': 'D', 'year': 'MMM'},
                    unitStepSize: 1
                }
            }

            if ($this.order === "reverse") {
                $this.data = $this.data.reverse();
                $this.labels = $this.labels.reverse();

            } else if ($this.order === "bigger") {
                $this.data = chartDataOrder($this.data, 'y');

                let labelsOrdened = [];
                for(let i in $this.data)
                    labelsOrdened.push($this.data[i].x.trim());
                $this.labels = labelsOrdened;

            } else if ($this.order === "smaller") {
                $this.data = chartDataOrder($this.data, 'y').reverse();

                let labelsOrdened = [];
                for(let i in $this.data)
                    labelsOrdened.push($this.data[i].x.trim());
                $this.labels = labelsOrdened;

            }

            if ($this.type[0] === "line") {
                options.scales.xAxes = [{
                    stacked: !0,
                    type: 'time',
                    gridLines: {
                        display: typeof $this.hideLineX === "undefined",
                        color: "#F5F5F5",
                        drawBorder: typeof $this.hideLineY === "undefined",
                        zeroLineWidth: 3,
                        zeroLineColor: "#EEEEEE"
                    },
                    ticks: {
                        padding: 0,
                        source: 'data',
                        autoSkip: !1,
                        stepSize: $this.stepX || undefined,
                        callback: $this.functionLabelX,
                        display: typeof $this.hideLabelX === "undefined"
                    },
                    time: {
                        unit: chartFilter.interval,
                        displayFormats: {'day': 'H', 'week': 'ddd', 'month': 'D', 'year': 'MMM'},
                        unitStepSize: 1
                    },
                    offset: !0
                }]
            }
        }
        return options
    }

    /**
     * Dataset padrão para todos os gráficos
     * @param $this
     * @returns {{pointBorderColor: string, backgroundColor: *, borderColor: *, tension: (*|number), pointHoverRadius: pointHoverRadius, data: *, borderWidth: number, pointBorderWidth: number, fill: *, pointRadius: pointRadius}[]}
     */
    function getDataSets($this, ctx) {

        let color = "undefined";
        if (typeof $this.colorBaseGradient !== "undefined") {
            color = ctx.createLinearGradient(0, 0, 0, 600);
            color.addColorStop(0, $this.colorBaseGradient[0]);
            color.addColorStop(1, $this.colorBaseGradient[1])
        } else if (typeof $this.backgroundColor !== "undefined") {
            color = $this.backgroundColor
        } else if (typeof $this.colorBase !== "undefined") {
            color = $this.colorBase
        }

        return [{
            data: $this.data,
            backgroundColor: color,
            borderColor: $this.type[0] === "line" ? $this.colorBase || "#cccccc" : undefined,
            pointBorderWidth: 0,
            pointBorderColor: "#FFFFFF",
            fill: (typeof $this.fill !== "undefined" ? $this.fill : !1),
            pointRadius: function (chart) {
                if (isEmpty(chart.dataset.data[chart.dataIndex].y) || chart.dataset.data[chart.dataIndex].y < chart.chart.options.scales.yAxes[0].ticks.min)
                    return 0;
                return (typeof $this.pointRadius !== "undefined" ? $this.pointRadius : 10)
            },
            pointHoverRadius: function (chart) {
                if (isEmpty(chart.dataset.data[chart.dataIndex].y) || chart.dataset.data[chart.dataIndex].y < chart.chart.options.scales.yAxes[0].ticks.min)
                    return 0;
                return (typeof $this.pointRadius !== "undefined" ? $this.pointRadius : 10) + 1
            },
            tension: (typeof $this.lineTension !== "undefined" ? $this.lineTension : ($this.type[0] === "line" ? .5 : 5)),
            borderWidth: $this.type[0] === "line" ? 2 : 1
        }]
    }

    /**
     * Função para a adição de imagens ao gráfico
     * @param $this
     * @param idChart
     */
    function privateChartGenerateImages($this, idChart) {
        if (typeof $this.functionImage === "function") {
            let images = {};
            let isImage = new RegExp(".(png|jpg|jpeg|webp)$", "i");
            $.each($this.data, function (i, data) {
                let src = $this.functionImage($this.functionAssocLabelY(data.y));
                if (isImage.test(src)) {
                    let imageObj = new Image();
                    imageObj.src = src;
                    imageObj.width = data.r * 3;
                    imageObj.height = data.r * 3;
                    images[i] = imageObj
                } else {
                    images[i] = ""
                }
            });
            Chart.pluginService.register({
                afterUpdate: function (chart) {
                    if (chart.options.idChart === idChart) {
                        $.each(chart.config.data.datasets[0].data, function (i, data) {
                            if (images[i] !== "") {
                                $.each(Object.keys(chart.config.data.datasets[0]._meta), function (ii, key) {
                                    chart.config.data.datasets[0]._meta[key].data[i]._model.pointStyle = (chart.options.funcitonImage ? images[i] : "")
                                })
                            }
                        })
                    }
                }
            })
        }
    }

    /**
     * Construtor para novo Gráfico com funções
     * @returns {{data: [], setMinY: setMinY, setHideLabelX: setHideLabelX, getDataLabel: (function(): [*, *]), setMinX: setMinX, setHideLabelY: setHideLabelY, stepX: number, stepY: number, type: [string], colorBaseGradient: string, setRoundValueStepY: setRoundValueStepY, setColorBaseGradient: setColorBaseGradient, hideLineY: boolean, setHideLineX: setHideLineX, hideLineX: boolean, setHideLineY: setHideLineY, paddings: null, options: {}, setOptions: setOptions, fieldY: null, fieldX: null, setLabels: setLabels, order: [], setRoundValueStepX: setRoundValueStepX, hideLabelY: boolean, hideLabelX: boolean, setFieldDate: setFieldDate, fieldDate: null, roundValueStepX: boolean, setTitle: setTitle, roundValueStepY: boolean, setColorBackgroundBase: setColorBackgroundBase, fill: boolean, setPaddings: setPaddings, labels: [], functionColor: null, operacao: string, setFunctionColor: setFunctionColor, functionValueY: null, setPointRadius: setPointRadius, setMaxY: setMaxY, setMaxX: setMaxX, lineTension: number, pointRadius: number, setLineTension: setLineTension, setOperacaoMaioria: setOperacaoMaioria, setFunctionImage: setFunctionImage, setFunctionValueY: setFunctionValueY, maxY: null, backgroundImage: null, functionValueX: null, setFunctionValueX: setFunctionValueX, maxX: null, functionAssocLabelY: null, setOrderBigger: setOrderBigger, title: string, setFunctionTooltips: setFunctionTooltips, setFill: setFill, borderWidth: number, setOperacaoSoma: setOperacaoSoma, setColorBase: setColorBase, colorBase: string, getData: (function(): *), setOrderReverse: setOrderReverse, backgroundColor: null, setData: setData, setGridOffsetLineY: setGridOffsetLineY, setOperacaoMedia: setOperacaoMedia, setGridOffsetLineX: setGridOffsetLineX, getChart: getChart, setType: setType, setFunctionLabelX: setFunctionLabelX, setFunctionLabelY: setFunctionLabelY, setFieldY: setFieldY, setOrder: setOrder, setFieldX: setFieldX, minY: number, minX: number, colorBackgroundBase: string, setOrderSmaller: setOrderSmaller, functionLabelX: null, functionLabelY: null, setBoderWidth: setBoderWidth, functionTooltips: null, gridOffsetLineY: boolean, gridOffsetLineX: boolean, setStepX: setStepX, setStepY: setStepY}}
     * @constructor
     */
    window.ChartMaker = function () {
        return {
            data: [],
            title: "",
            type: ["bar"],
            fieldX: null,
            fieldY: null,
            fieldDate: null,
            operacao: "sum",
            labels: [],
            stepY: 1,
            stepX: 1,
            order: [],
            roundValueStepX: !1,
            roundValueStepY: !1,
            minX: 0,
            minY: 0,
            maxX: null,
            maxY: null,
            hideLineY: !1,
            hideLineX: !1,
            hideLabelY: !1,
            hideLabelX: !1,
            backgroundColor: null,
            backgroundImage: null,
            functionValueX: null,
            functionValueY: null,
            functionLabelX: null,
            functionLabelY: null,
            functionAssocLabelY: null,
            functionTooltips: null,
            functionColor: null,
            borderWidth: 1,
            paddings: null,
            lineTension: 5,
            gridOffsetLineY: !1,
            gridOffsetLineX: !1,
            pointRadius: 10,
            colorBase: "",
            colorBaseGradient: "",
            colorBackgroundBase: "",
            fill: !1,
            options: {},
            setTitle: title => {
                if (typeof title === "string")
                    this.title = title
            },
            setData: data => {
                if (typeof data !== "undefined" && data !== null && data.constructor === Array)
                    this.data = data
            },
            setType: type => {
                this.type = operatorChartSetType(type)
            },
            setColorBase: color => {
                this.colorBase = color
            },
            setColorBaseGradient: (color1, color2) => {
                if (typeof color1 !== "undefined" && color2 !== "undefined")
                    this.colorBaseGradient = [color1, color2]
            },
            setFill: fill => {
                this.fill = fill
            },
            setColorBackgroundBase: color => {
                this.colorBackgroundBase = color
            },
            setLineTension: tension => {
                this.lineTension = tension
            },
            setPointRadius: pointRadius => {
                this.pointRadius = pointRadius
            },
            setOrder: order => {
                if (typeof order === "object" && order.constructor === Array)
                    this.order = order
            },
            setOrderBigger: () => {
                this.order = 'bigger'
            },
            setOrderSmaller: () => {
                this.order = 'smaller'
            },
            setOrderReverse: () => {
                this.order = 'reverse'
            },
            setFieldX: x => {
                if (typeof x === "string")
                    this.fieldX = x
            },
            setFieldY: y => {
                if (typeof y === "string" || (typeof y !== "undefined" && y !== null && y.constructor === Array))
                    this.fieldY = y
            },
            setFieldDate: date => {
                let dateCheck = new RegExp("^\\d{4}-\\d{2}-\\d{2}(\\s\\d{2}:\\d{2}:\\d{2})*$", "i");
                if (dateCheck)
                    this.fieldDate = date
            },
            setLabels: l => {
                if (typeof l === "object" && l.constructor === Array)
                    this.labels = l
            },
            setOperacaoSoma: () => {
                this.operacao = "sum"
            },
            setOperacaoMedia: () => {
                this.operacao = "media"
            },
            setOperacaoMaioria: () => {
                this.operacao = "maioria"
            },
            setStepX: step => {
                if (!isNaN(step))
                    this.stepX = step
            },
            setStepY: step => {
                if (!isNaN(step))
                    this.stepY = step
            },
            setRoundValueStepX: () => {
                this.roundValueStepX = !0
            },
            setRoundValueStepY: () => {
                this.roundValueStepY = !0
            },
            setMinX: min => {
                if (!isNaN(min))
                    this.minX = min
            },
            setMaxX: max => {
                if (!isNaN(max))
                    this.maxX = max
            },
            setMinY: min => {
                if (!isNaN(min))
                    this.minY = min
            },
            setMaxY: max => {
                if (!isNaN(max))
                    this.maxY = max
            },
            setHideLineY: () => {
                this.hideLineY = !0
            },
            setHideLineX: () => {
                this.hideLineX = !0
            },
            setHideLabelY: () => {
                this.hideLabelY = !0
            },
            setHideLabelX: () => {
                this.hideLabelX = !0
            },
            setBoderWidth: b => {
                if (!isNaN(b))
                    this.borderWidth = b
            },
            setPaddings: p => {
                this.paddings = {top: 30, right: 20, bottom: 30, left: 0};
                if (typeof p === "object" && p.constructor === Object) {
                    if (!isNaN(p.top))
                        this.paddings.top = p.top;
                    if (!isNaN(p.right))
                        this.paddings.right = p.right;
                    if (!isNaN(p.bottom))
                        this.paddings.bottom = p.bottom;
                    if (!isNaN(p.left))
                        this.paddings.left = p.left
                }
            },
            setFunctionValueX: f => {
                if (typeof f === "function")
                    this.functionValueX = f
            },
            setFunctionValueY: f => {
                if (typeof f === "function")
                    this.functionValueY = f
            },
            setFunctionLabelX: f => {
                if (typeof f === "function")
                    this.functionLabelX = f
            },
            setFunctionLabelY: f => {
                if (typeof f === "function")
                    this.functionLabelY = f
            },
            setFunctionTooltips: f => {
                if (typeof f === "function")
                    this.functionTooltips = f
            },
            setFunctionColor: f => {
                if (typeof f === "function")
                    this.functionColor = f
            },
            setFunctionImage: f => {
                if (typeof f === "function")
                    this.functionImage = f
            },
            setGridOffsetLineY: gridOffsetLineY => {
                if (typeof gridOffsetLineY === "undefined" || typeof gridOffsetLineY === "boolean")
                    this.gridOffsetLineY = !0
            },
            setGridOffsetLineX: gridOffsetLineX => {
                if (typeof gridOffsetLineY === "undefined" || typeof gridOffsetLineX === "boolean")
                    this.gridOffsetLineX = !0
            },
            setOptions: o => {
                if (typeof o === "object")
                    this.options = o
            },

            /**
             * Obtém os dados do gráfico
             * @returns {*}
             */
            getData: () => {
                let $this = this;
                if (typeof $this.labels === "undefined" || isEmpty($this.labels))
                    $this = privateChartGenerateBase($this);
                return $this.data
            },

            /**
             * Obtém os dados e as labels do gráfico
             * @returns {[*, *]}
             */
            getDataLabel: () => {
                let $this = this;
                if (typeof $this.labels === "undefined" || isEmpty($this.labels))
                    $this = privateChartGenerateBase($this);
                return [$this.data, $this.labels]
            },

            /**
             * Obtém o gráfico
             * @param type
             * @returns {jQuery|HTMLElement}
             */
            getChart: type => {
                let $this = this;

                /**
                 * Verifica se os dados já foram gerados ou se precisa gerar
                 */
                if (typeof $this.labels === "undefined" || isEmpty($this.labels))
                    $this = privateChartGenerateBase($this, type);
                else if (typeof type !== "undefined")
                    $this.type = operatorChartSetType(type);

                if (isEmpty($this.data)) {

                    /**
                     * Caso não tenha dados para exibir
                     */
                    return $("<div class='col'><h3 class='padding-64 align-center font-bold font-xlarge color-text-gray'>" + lang.nenhum + "</h3></div>")
                } else {

                    /**
                     * Gera o gráfico para devolução
                     */
                    let options = privateChartGenerateOptions($this);
                    privateChartGenerateImages($this, options.idChart);
                    $(".grafico-header").last().css("color", $this.colorBase);
                    let $canvas = $("<canvas></canvas>");
                    let ctx = $canvas[0].getContext('2d');

                    /**
                     * Espera para gerar o gráfico para poder adicionar a animação
                     * no gráfico, retire o timeout para remover a animação
                     */
                    setTimeout(function () {
                        new Chart(ctx, {
                            type: $this.type[0],
                            data: {labels: $this.labels, datasets: getDataSets($this, ctx)},
                            options: Object.assign(options, $this.options)
                        })
                    }, 1);

                    return $canvas;
                }
            }
        }
    };

    /**
     * Gera o gráfico de Sintomas
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoSintomas(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        for (let i in registrosBase) {
            if (isInFilterDate(registrosBase[i].created) && typeof registrosBase[i].title === "string" && registrosBase[i].title !== "") {
                let dh = registrosBase[i].created.split(" ");
                registrosBase[i].date = dh[0];
                registrosBase[i].hour = dh[1];
                registros.push(registrosBase[i])
            }
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setHideLineX();
        grafico.setTitle(getTitleIndicador("sintomas"));
        grafico.setMinY(0);
        grafico.setColorBase("#DE5690");
        grafico.setFieldY("title");

        function labelY(y) {
            if (typeof y === "string") {
                switch (y) {
                    case 'Dificuldade para falar':
                        return "Dific. p/ falar";
                        break;
                    case 'Confusão':
                        return "Confusão    ";
                        break;
                    case 'Sonolento, cansado':
                        return "Sonolento   ";
                        break;
                    case 'Dor de cabeça':
                        return "Dor de cabe";
                        break;
                    case 'Tontura':
                        return "Tontura        ";
                        break;
                    case 'Fraqueza em um membro':
                        return "Fraq. memb";
                        break;
                    default:
                        return "Outros"
                }
            }
        }

        /**
         * Verifica se precisa adicionar a seta para o gráfico anterior
         */
        if (modChart.sintomas > 1)
            $content.append(Mustache.render(tpl.graficoArrowBack, {indicador: 'sintomas', mod: 1}));

        if (modChart.sintomas === 1) {

            /**
             * Gráfico de Sintomas 1
             */
            let data = grafico.getDataLabel();
            let labels = data[1];
            let labelsNew = [];
            data = data[0];
            let total = 0;
            let bigger = {name: "", v: 0};
            let dataNew = [];

            for (let i in data) {
                if (typeof data[i] !== "" && !isNaN(data[i]))
                    total += data[i];
                labelsNew[i] = labelY(labels[i])
            }

            for (let i in data) {
                let v = Math.round(parseFloat((data[i] * 100) / total));
                if (v > bigger.v)
                    bigger = {name: labels[i], v: v};
                dataNew.push({x: labelsNew[i], y: v, v: v, r: ''})
            }

            grafico.setData(dataNew);
            grafico.setLabels(labelsNew);
            grafico.setOrderBigger();
            grafico.setFunctionLabelY(y => {
                if (y % 10 === 0)
                    return y + "%          ";
                return ""
            });

            grafico.setFunctionTooltips((y, x) => {
                return x + "% " + y
            });

            let totalCrises = 0;
            for (let i in registros) {
                if (registros[i].date <= chartFilter.dateEnd && registros[i].date >= chartFilter.dateStart)
                    totalCrises++
            }

            setTimeout(function () {
                $("#sub-header-sintomas").html((totalCrises + " " + lang.crisesPeriodo));
                $("#grafico-header-title-sintomas").html(Mustache.render(tpl.graficoHeaderSubtitle, {title: lang.relTitleSintoma, valor: bigger.v + "%", descricao: bigger.name + " " + lang.noPeriodoSintomas}))
            }, 1);

            grafico.setFieldX("x");
            $content.append(grafico.getChart("bar"))
        } else {

            /**
             * Gráfico de Sintomas 2
             */
            grafico.setGridOffsetLineY();
            grafico.setFunctionLabelY(labelY);
            grafico.setFieldDate("date");
            grafico.setFieldX("date");
            $content.append(grafico.getChart("bubble"))
        }

        /**
         * Verifica se precisa adicionar a seta para próximo gráfico
         */
        if (modChart.sintomas < 2)
            $content.append(Mustache.render(tpl.graficoArrowForward, {indicador: 'sintomas', mod: 2}));

        return $content
    }

    /**
     * Gráfico de Medicamentos
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoMedicamentos(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        let now = new Date(chartFilter.dateStart + " 00:00:00");
        let end = new Date(chartFilter.dateEnd + " 23:59:59");

        for (let d = now; d <= end; d.setDate(d.getDate() + 1)) {
            let day = moment(d).format('YYYY-MM-DD');

            for (let i in registrosBase) {
                let startDate = new Date(registrosBase[i].start_date);
                startDate.setHours(0, 0, 0, 0);
                let endDate = end;

                if (registrosBase[i].end_date !== "0000-00-00 00:00:00") {
                    let endDateTime = new Date(registrosBase[i].end_date);
                    endDateTime.setHours(0, 0, 0, 0);
                    endDate = (endDateTime < endDate ? endDateTime : endDate)
                }

                if (d <= endDate && d >= startDate && typeof registrosBase[i].name === "string" && registrosBase[i].name !== "")
                    registros.push(Object.assign({date: day}, {name: registrosBase[i].name}))
            }
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldY("name");
        grafico.setMinY(0);
        grafico.setStepY(1);
        grafico.setHideLineX();
        grafico.setTitle(getTitleIndicador("medicamentos"));
        grafico.setColorBase("#F0C773");

        /**
         * Verifica se precisa adicionar a seta para o gráfico anterior
         */
        if (modChart.medicamentos > 1)
            $content.append(Mustache.render(tpl.graficoArrowBack, {indicador: 'medicamentos', mod: 1}));

        if (modChart.medicamentos === 1) {

            /**
             * Gráfico de Medicamentos 1
             */
            grafico.setFunctionLabelY((label) => {
                if (typeof label === "string") {
                    if (label.length < 13) {
                        for (let i = label.length; i < 13; i++)
                            label += " "
                    } else if (label.length > 12) {
                        label = label.substring(0, 12)
                    }
                    return label
                }
            });

            var colorMedicamentosCount = 0;
            var nameMedicamentosColor = {};
            var colorsMedicamentos = ["#7DA0D4", "#FF5159", "#5EA397", "#6849B7", "#2D92CB", "#7EC8BD"];

            grafico.setFunctionColor(function (name) {
                if (typeof name === "string") {
                    if (typeof nameMedicamentosColor[name] === "undefined") {
                        nameMedicamentosColor[name] = colorMedicamentosCount < 6 ? colorsMedicamentos[colorMedicamentosCount] : "#606060";
                        colorMedicamentosCount++
                    }
                    return nameMedicamentosColor[name]
                }
            });

            grafico.setOrderReverse();
            grafico.setGridOffsetLineY();
            grafico.setFieldDate("date");
            grafico.setFieldX("date");
            $content.append(grafico.getChart("bubble"));
        } else {

            /**
             * Gráfico de Medicamentos 2
             */
            let data = grafico.getDataLabel();
            let labels = data[1];
            let labelsNew = [];
            data = data[0];
            let total = 0;
            let bigger = {name: "", v: 0};
            let dataNew = [];

            for (let i in data) {
                if (typeof data[i] !== "" && !isNaN(data[i]))
                    total += data[i];
                labelsNew[i] = labels[i]
            }

            for (let i in data) {
                let v = Math.round(parseFloat((data[i] * 100) / total));
                if (v > bigger.v)
                    bigger = {name: labels[i], v: v};
                dataNew.push({x: labelsNew[i], y: v, v: v, r: ''})
            }

            grafico.setData(dataNew);
            grafico.setLabels(labelsNew);
            grafico.setFunctionLabelY(y => {
                if (y % 10 === 0)
                    return y + "%          ";
                return ""
            });

            grafico.setFunctionTooltips((y, x) => {
                return x + "% " + y
            });

            setTimeout(function () {
                $("#grafico-header-title-medicamentos").html(Mustache.render(tpl.graficoHeaderSubtitle, {title: lang.relTitleMedicamentos, valor: bigger.v + "%", descricao: bigger.name + " " + lang.noPeriodoMedicamentos}));
            }, 1);

            grafico.setOrderBigger();
            grafico.setFieldX("x");
            $content.append(grafico.getChart("bar"));
        }

        /**
         * Verifica se precisa adicionar a seta para próximo gráfico
         */
        if (modChart.medicamentos < 2)
            $content.append(Mustache.render(tpl.graficoArrowForward, {indicador: 'medicamentos', mod: 2}));

        return $content
    }

    /**
     * Gráfico de Atividades
     * @param registros
     * @returns {jQuery|HTMLElement}
     */
    function graficoAtividade(registros) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        for (let i in registros) {
            if(modChart['atividade-fisica'] === 3) {
                registros[i].runningMeters = parseInt(registros[i].runningMeters);
            } else if(modChart['atividade-fisica'] === 4) {
                if (typeof registros[i].runningTime === "string" && registros[i].runningTime !== "" && registros[i].runningTime.indexOf(":") > 0) {
                    let p = registros[i].runningTime.split(":");
                    if (typeof p[1] !== "undefined" && !isNaN(p[0]) && !isNaN(p[1]))
                        registros[i].runningTime = parseFloat(parseFloat(p[0] + "." + ((p[1] * 100) / 60)).toFixed(2));
                    else
                        registros[i].runningTime = parseFloat(0);

                } else if(typeof registros[i].runningTime === "string" && registros[i].runningTime !== "" && !isNaN(registros[i].runningTime)) {
                    registros[i].duration = parseFloat(registros[i].runningTime);

                } else {
                    registros[i].runningTime = parseFloat(0);
                }
            }

            let dh = registros[i].date_hour.split(" ");
            registros[i].date = dh[0];
            registros[i].hour = dh[1]
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("date");
        grafico.setFieldX("date");

        /**
         * Para cada tipo de gráfico diferente de Atividade, define o campo Y adequado
         */
        if (modChart['atividade-fisica'] === 1)
            grafico.setFieldY("kilo_burn_activity");
        else if (modChart['atividade-fisica'] === 2)
            grafico.setFieldY("FloorsClimbed");
        else if (modChart['atividade-fisica'] === 3)
            grafico.setFieldY("runningMeters");
        else if (modChart['atividade-fisica'] === 4)
            grafico.setFieldY("duration");
        else if (modChart['atividade-fisica'] === 5)
            grafico.setFieldY("footsteps");

        grafico.setPointRadius(0);
        grafico.setHideLineX();

        if(chartFilter.interval === "year")
            grafico.setOperacaoMedia();
        else
            grafico.setOperacaoSoma();

        grafico.setMinY(0);
        grafico.setColorBase("#c14973");

        grafico.setFunctionLabelY(function (y) {
            if (modChart['atividade-fisica'] === 1) {
                return y + (y.length === 5 ? "         " : (y.length === 4 ? "         " : (y.length === 3 ? "         " : (y.length === 2 ? "          " : "            "))))
            } else if (modChart['atividade-fisica'] === 2) {
                return y + (y.length === 5 ? "       " : (y.length === 4 ? "       " : (y.length === 3 ? "       " : (y.length === 2 ? "        " : "          "))))
            } else if (modChart['atividade-fisica'] === 3) {
                return y + (y.length === 5 ? "           " : (y.length === 4 ? "             " : (y.length === 3 ? "              " : (y.length === 2 ? "              " : "                "))))
            } else if (modChart['atividade-fisica'] === 4) {
                return y + (y.length === 5 ? "          " : (y.length === 4 ? "            " : (y.length === 3 ? "             " : (y.length === 2 ? "             " : "               "))))
            } else {
                return y + (y.length === 5 ? "         " : (y.length === 4 ? "           " : (y.length === 3 ? "           " : (y.length === 2 ? "            " : "              "))))
            }
        });

        if(modChart['atividade-fisica'] === 4) {
            grafico.setFunctionTooltips(function (x, y) {
                return zeroEsquerda(Math.floor(y)) + ":" + zeroEsquerda(Math.round(y % 1 * 60)) + " min"
            });
        } else {
            grafico.setFunctionTooltips(function (x, y) {
                y = parseFloat(y).toFixed(1).toString().replace(".", ",");
                if (y.length > 5)
                    y = [y.slice(0, y.length - 5), ".", y.slice(y.length - 5)].join('');
                return y + (modChart['atividade-fisica'] === 3 ? " m" : "");
            });
        }

        /**
         * Obtém os dados do gráfico para poder gerar a média dos registros
         */
        let data = grafico.getData();
        if (data.length) {
            let media = 0.0;
            let total = 0;
            for (let i in data) {
                if (data[i].y !== "" && !isNaN(data[i].y)) {
                    media += parseFloat(data[i].y);
                    total++;
                }
            }

            media = parseFloat(media / total).toFixed(1).toString();
            if(modChart['atividade-fisica'] === 4) {
                if (!isNaN(media))
                    media = zeroEsquerda(Math.floor(media)) + ":" + zeroEsquerda(Math.round(media % 1 * 60));
                else
                    media = "00:00";
            } else {
                media = media.replace(".", ",");
                if (media.length > 5)
                    media = [media.slice(0, media.length - 5), ".", media.slice(media.length - 5)].join('');
            }

            /**
             * Altera o título do gráfico com o valor de média encontado
             */
            setTimeout(function () {
                $("#grafico-header-title-atividade-fisica").html(Mustache.render(tpl.graficoHeaderSubtitle, {title: lang.relTitleAtividade, valor: media, descricao: getTitleIndicador("atividade-fisica") + " " + lang.noPeriodoAtividade}));
            }, 1)
        }

        /**
         * Gráfico 5 configurações personalizadas
         */
        if (modChart['atividade-fisica'] === 5) {
            grafico.setLineTension(0);
            grafico.setFill(!0);
            grafico.setColorBaseGradient("#c14973", "rgba(255,255,255,0)")
        }

        /**
         * Verifica se precisa adicionar a seta para o gráfico anterior
         */
        if (modChart['atividade-fisica'] > 1)
            $content.append(Mustache.render(tpl.graficoArrowBack, {
                indicador: 'atividade-fisica',
                mod: modChart['atividade-fisica'] - 1
            }));

        /**
         * Gráficos 2 e 3 são em baras, demais em linhas
         */
        if (modChart['atividade-fisica'] === 2 || modChart['atividade-fisica'] === 3)
            $content.append(grafico.getChart("bar"));
        else
            $content.append(grafico.getChart("line"));

        /**
         * Verifica se precisa adicionar a seta para o próximo gráfico
         */
        if (modChart['atividade-fisica'] < 5)
            $content.append(Mustache.render(tpl.graficoArrowForward, {
                indicador: 'atividade-fisica',
                mod: modChart['atividade-fisica'] + 1
            }));

        setTimeout(function () {
            $(".grafico-header-atividade-fisica").html(lang[getTitleIndicador("atividade-fisica").toLowerCase()]);
        }, 1);

        return $content;
    }

    /**
     * Gráfico de Crises
     * @param registros
     * @returns {jQuery|HTMLElement}
     */
    function graficoCrises(registros) {

        /**
         * Gráfico de Crises 2 manda para outra função fazer a operação
         */
        if (modChart.crises === 2)
            return graficoCrises2(registros);

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("created");
        grafico.setFieldX("created");
        grafico.setFieldY("seizure_intensity");
        grafico.setHideLineX();
        grafico.setHideLabelY();
        grafico.setOperacaoMedia();
        grafico.setStepY(5);
        grafico.setTitle(getTitleIndicador("crises"));

        let funcaoLabelY = title => {
            if (isEmpty(title)) {
                return ""
            } else if (title === 0)
                return lang.criseNao;
            else if (title < 3)
                return lang.criseFraca;
            else if (title < 6)
                return lang.criseMedia;

            return lang.criseForte;
        };

        grafico.setFunctionTooltips(function (x, y) {
            if (y === 10)
                return lang.criseForte;
            else if (y === 5)
                return lang.criseMedia;

            return lang.criseFraca;
        });

        grafico.setFunctionColor(function (y) {
            if (y < 3)
                return "#FF6D6D";
            else if (y < 6)
                return "#CD3B3B";

            return "#6F0000"
        });

        grafico.setFunctionLabelY(funcaoLabelY);
        grafico.setMaxY(10);
        grafico.setMinY(0);
        let listXComentarios = [];

        for (let i in registros) {
            if (typeof listXComentarios[registros[i].created] === "undefined")
                listXComentarios[registros[i].created] = "";
            if (!isEmpty(registros[i].comment))
                listXComentarios[registros[i].created] += " - " + registros[i].comment + ".<br><br>"
        }

        let listX = [];
        let data = grafico.getData();
        data = chartDataOrder(data, "x").reverse();
        let xComments = [];

        if(chartFilter.interval === "day") {
            for (let i in registros) {
                if(registros[i].created === chartFilter.dateStart) {
                    if (typeof registros[i].comment === "string" && registros[i].comment.length)
                        xComments.push("<b>" + moment(chartFilter.dateStart).format("ll") + "</b><br><br>" + registros[i].comment);
                    else
                        xComments.push("")
                }
            }
            for (let i in data) {
                let v = data[i].y;

                listX.push({
                    img: "nivel" + (!isEmpty(v) ? (v === 0 ? "" : (v < 3 ? 1 : (v < 6 ? 2 : 3))) : 0),
                    style: (isEmpty(v) ? "padding-top: 5px;" : ""),
                    title: funcaoLabelY(v)
                });
            }
        } else {
            for (let i in data) {
                let v = data[i].y;

                listX.push({
                    img: "nivel" + (!isEmpty(v) ? (v === 0 ? "" : (v < 3 ? 1 : (v < 6 ? 2 : 3))) : 0),
                    style: (isEmpty(v) ? "padding-top: 5px;" : ""),
                    title: funcaoLabelY(v)
                });

                if(chartFilter.interval === "year") {
                    let textoMes = "<b>" + moment(data[i].x).format("MMMM") + "</b><br><br>";
                    comentarios = textoMes;
                    let mes = data[i].x.split("-");
                    mes = mes[0] + "-" + zeroEsquerda(mes[1]);

                    for(let e in listXComentarios) {

                        /**
                         * Se tiver valor neste mês e a data estiver entre o intervalor, e somente registros do mês atual e tiver comentário
                         */
                        if(!isEmpty(v) && typeof e === "string" && e >= chartFilter.dateStart && e <= chartFilter.dateEnd && e.indexOf(mes) === 0 && typeof listXComentarios[e] === "string" && listXComentarios[e].length)
                            comentarios += "<b style='float:left; width: 100%;text-align: left;padding-bottom: 10px;'>" + moment(e).format("ll") + ":</b><div style='width:100%;float:left;padding:0 0 15px 30px;text-align:left'>" + listXComentarios[e] + "</div>";
                    }

                    if(comentarios !== textoMes)
                        xComments.push(comentarios);
                    else
                        xComments.push("")

                } else {
                    if (typeof listXComentarios[data[i].x] === "string" && listXComentarios[data[i].x].length)
                        xComments.push("<b>" + moment(data[i].x).format("ll") + "</b><br><br>" + listXComentarios[data[i].x]);
                    else
                        xComments.push("")
                }
            }
        }

        setTimeout(function () {
            let intensidadeBlock = $content.find(".grafico-crises-intensidade");
            let xSpace = intensidadeBlock[0].clientWidth - parseInt(intensidadeBlock.css("padding-left")) - parseInt(intensidadeBlock.css("padding-right")) - 2;
            let widthList = xSpace / listX.length;
            let percentWidth = (widthList < 30 ? .8 : (widthList < 50 ? .76 : (widthList < 70 ? .66 : (widthList < 90 ? .5 : .4))));
            let percentMargin = (widthList < 30 ? .1 : (widthList < 50 ? .12 : (widthList < 70 ? .17 : (widthList < 90 ? .25 : .3))));
            $(".grafico-crises-intensidade").find(".img-proporcion").css({
                width: (widthList * percentWidth) + "px",
                margin: "0 " + (widthList * percentMargin) + "px"
            })
        }, 1);

        /**
         * Adiciona a seta para próximo gráfico
         */
        $content.append(Mustache.render(tpl.graficoArrowForward, {indicador: 'crises', mod: 2, style: "top: 170px;"}));

        /**
         * Adiciona todos os gráficos de crises em um só gráfico
         */
        getRequest('public/tpl/graficoCrisesIntensidade.mustache');
        $content.append(Mustache.render(tpl.graficoCrisesIntensidade, Object.assign({x: listX}, lang)));
        $content.append(graficoCrisesDuracao(registros));
        $content.append(graficoCrisesPeriodo(registros));
        $content.append(graficoCrisesRecuperacao(registros));
        $content.append(Mustache.render(tpl.graficoCrisesComentarios, Object.assign({x: xComments}, lang)));

        return $content
    }

    /**
     * Obtém os dados (registros do gráfico de Calendário de Crises)
     * @param registros
     * @returns {[]}
     */
    function privateChartGetDataCrisesCalendar(data) {
        let listX = [];
        if (typeof data === "object" && data.constructor === Object && !isEmpty(data)) {

            /**
             * Função para dar nome aos campos no calendário
             */
            let funcaoTooltips = (x, y) => { return (isEmpty(y) ? "" : (y < 3 ? lang.criseFraca : (y < 6 ? lang.criseMedia : lang.criseForte))); }
            let funcaoColor = y => { return (y < 3 ? "#FF6D6D" : (y < 6 ? "#CD3B3B" : "#6F0000")); }

            if (chartFilter.interval === "day") {
                for (let i in data) {
                    let v = data[i].y;
                    listX.push({
                        title: funcaoTooltips("", v),
                        style: (!isEmpty(v) ? "color: #FFF;background: " + funcaoColor(v) : ""),
                        dia: ""
                    })
                }

            } else {

                /**
                 * Para cada registro, preenche no calendário
                 */

                let date = moment(chartFilter.dateStart);
                let formatDate = date.subtract(parseInt(date.format("d")), 'days');
                formatDate = formatDate.format("YYYY-MM-DD");

                let formatDateEnd = moment(chartFilter.dateEnd);
                formatDateEnd.add(7 - parseInt(formatDateEnd.format("d")), 'days');
                formatDateEnd = formatDateEnd.format("YYYY-MM-DD");

                while(formatDate !== formatDateEnd) {
                    if(typeof data[formatDate] !== "undefined") {
                        listX.push({
                            title: funcaoTooltips("", data[formatDate]),
                            style: (!isEmpty(data[formatDate]) ? "color: #FFF;background: " + funcaoColor(data[formatDate]) : ""),
                            dia: (chartFilter.interval === "year" ? (!isEmpty(data[formatDate]) && !isNaN(data[formatDate]) ? "" : "-") : parseInt(date.format("D")))
                        })
                    } else {
                        listX.push({
                            title: "",
                            style: "",
                            dia: (chartFilter.interval === "year" ? (!isEmpty(data[formatDate]) && !isNaN(data[formatDate]) ? "" : "-") : parseInt(date.format("D")))
                        })
                    }

                    date.add(1, "days");
                    formatDate = date.format('YYYY-MM-DD');
                }
            }
        }

        console.log(listX);

        return listX;
    }

    /**
     * Obtém as labels do gráfico de Crises calendário
     * @param isPrevius
     * @returns {string|void}
     */
    function privateChartGetLabelCalendar() {

        if (chartFilter.interval === "day") {
            return "dia " + moment(chartFilter.dateStart).format("DD")
        } else if (chartFilter.interval === "week") {
            let semanaInicial = Math.ceil(moment(chartFilter.dateStart).date() / 7);
            let semanaFinal = Math.ceil(moment(chartFilter.dateEnd).date() / 7);
            let mesInicial = moment(chartFilter.dateStart).format("MMMM");
            let mesFinal = moment(chartFilter.dateEnd).format("MMMM");
            return (mesInicial !== mesFinal ? (semanaInicial + "ª semana de " + mesInicial + "<br>" + semanaFinal + "ª semana de " + mesFinal) : (semanaInicial + ( semanaInicial !== semanaFinal ? " e " + semanaFinal : "") + "ª semana de " + mesInicial));
        } else if (chartFilter.interval === "month") {
            let mesInicial = moment(chartFilter.dateStart).format("MMMM");
            let mesFinal = moment(chartFilter.dateEnd).format("MMMM");
            return mesInicial + (mesInicial !== mesFinal ? " / " + mesFinal : "");
        }

        return moment(chartFilter.dateStart).format("YYYY");
    }

    /**
     * Gráfico de Crises Calendário
     * @param registros
     * @returns {jQuery|HTMLElement}
     */
    function graficoCrises2(registrosBase) {

        /**
         * Converte lista de registros em data referenciada por dia
         */
        let data = [];
        for(let i in registrosBase) {
            if(isInFilterDate(registrosBase[i].created))
                data.push(registrosBase[i]);
        }
        data = chartDataOrder(data, "created").reverse();

        /**
         * Para cada registro, buscar a soma dos valores de intensidade da crise por dia
         */
        let registros = {};
        let total = {};
        for (let i in data) {
            if (!isEmpty(data[i].seizure_intensity) && !isNaN(data[i].seizure_intensity)) {
                if (typeof registros[data[i].created] === "undefined") {
                    registros[data[i].created] = 0;
                    total[data[i].created] = 0;
                }

                registros[data[i].created] += data[i].seizure_intensity;
                total[data[i].created]++;
            }
        }

        /**
         * associa valor médio da intensidade da crise no dia
         */
        for (let i in registros)
            registros[i] = parseFloat(parseFloat(registros[i] / total[i]).toFixed(1));

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");

        if (chartFilter.interval === "year") {
            getRequest('public/tpl/chartCalendarYearBubble.mustache').then(templateCalendar => {
                $content.append(Mustache.render(templateCalendar, Object.assign({
                    x: privateChartGetDataCrisesCalendar(registros),
                    label: privateChartGetLabelCalendar()
                }, lang)));
            });

        } else if (chartFilter.interval === "day") {

        } else {

            getRequest('public/tpl/chartCalendarBubble.mustache').then(templateCalendar => {

                let calendar1 = Mustache.render(templateCalendar, Object.assign({
                    x: privateChartGetDataCrisesCalendar(registros),
                    label: privateChartGetLabelCalendar()
                }, lang));

                /*let calendar2 = Mustache.render(templateCalendar, Object.assign({
                    x: privateChartGetDataCrisesCalendar(registros),
                    label: privateChartGetLabelCalendar()
                }, lang));*/

                $content.append(Mustache.render(tpl.graficoCrisesCalendar, Object.assign({
                    calendar1: calendar1
                    // calendar2: calendar2
                }, lang)));
            });
        }

        /**
         * Adiciona a seta para o gráfico anterior
         */
        $content.append(Mustache.render(tpl.graficoArrowBack, {indicador: 'crises', mod: 1, style: "top: 170px;"}));

        return $content
    }

    /**
     * Gráfico de Crises Duração
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoCrisesDuracao(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        for (let i in registrosBase) {
            for (let e in registrosBase[i].answers) {
                if (registrosBase[i].answers[e].id === 5 && registrosBase[i].answers[e].option !== 82) {
                    let duracao = parseInt(registrosBase[i].answers[e].answerlabel.replace("0-", "").replace("1-3", "2").replace("3-5", "3").replace("Maior que 5", "4").replace("min").trim());
                    registros.push({date: registrosBase[i].created, duracao: duracao})
                }
            }
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("date");
        grafico.setFieldX("date");
        grafico.setFieldY("duracao");
        grafico.setOptions({aspectRatio: 7});
        grafico.setOperacaoMedia();
        grafico.setHideLineX();
        grafico.setStepY(1);
        grafico.setColorBase("#8888C1");
        grafico.setRoundValueStepY();

        grafico.setFunctionLabelY(y => {
            return (y === 1 ? lang.graficoCrise1min + "        " : ((y === 2 ? lang.graficoCrise3min + "        " : ((y === 3 ? lang.graficoCrise5min + "        " : (y === 4 ? lang.graficoCrise10min + "        " : ""))))))
        });

        grafico.setFunctionTooltips((x, y) => {
            return (y === 1 ? lang.graficoCrise1min : ((y === 2 ? lang.graficoCrise3min : ((y === 3 ? lang.graficoCrise5min : (y === 4 ? lang.graficoCrise15min : ""))))))
        });

        grafico.setTitle(lang.durCrise);
        grafico.setPaddings({left: 0, right: 20, bottom: 0, top: 20});
        $content.append('<div class="col" style="min-width: 790px;"><h4 class="font-medium font-bold margin-0 padding-0" id="grafico-header-title-recuperacao">' + lang.durCrise + '</h4></div>');
        $content.append(grafico.getChart());

        return $content
    }

    /**
     * Gráfico de Crises Período
     * @param registros
     * @returns {jQuery|HTMLElement}
     */
    function graficoCrisesPeriodo(registros) {

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("created");
        grafico.setFieldX("created");
        grafico.setFieldY("seizure_period");
        grafico.setHideLineX();
        grafico.setHideLabelX();
        grafico.setOptions({aspectRatio: 7});
        grafico.setGridOffsetLineY();
        grafico.setMinY(1);
        grafico.setStepY(1);
        grafico.setMaxY(3);
        grafico.setOrder(["night", "evening", "morning"]);

        grafico.setFunctionLabelY(function (y) {
            switch (y) {
                case 'morning':
                    return lang.graficoCriseManha + "         ";
                case 'evening':
                    return lang.graficoCriseTarde + "           ";
                case 'night':
                    return lang.graficoCriseNoite + "           "
            }
        });

        grafico.setFunctionImage(function (y) {
            switch (y) {
                case 'morning':
                    return "public/assets/img/graficos/crises/sun.png";
                case 'evening':
                    return "public/assets/img/graficos/crises/montain.png";
                case 'night':
                    return "public/assets/img/graficos/crises/moon.png"
            }
        });

        grafico.setFunctionColor(function (y) {
            switch (y) {
                case 'morning':
                    return "#ECC31E";
                case 'evening':
                    return "#7EA9C7";
                case 'night':
                    return "#7E87C8"
            }
        });

        grafico.setTitle(lang.periodo);
        grafico.setPaddings({left: 0, right: 20, bottom: 0, top: 20});
        $content.append('<div class="col" style="min-width: 790px;"><h4 class="font-medium font-bold margin-0 padding-0" id="grafico-header-title-recuperacao">' + lang.periodo + '</h4></div>');
        $content.append(grafico.getChart("bubble"));
        return $content
    }

    /**
     * Gráfico de Crises Recuperação
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoCrisesRecuperacao(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        let referenciaN = {
            "Não sei": 1,
            "Imediatamente": 2,
            "30 min": 3,
            "1 horas": 4,
            "1-6 horas": 5,
            "6-12 horas": 6
        };
        let referencia = {
            1: lang.graficoCriseNaoSei + "        ",
            2: lang.graficoCriseImediatamente + "       ",
            3: lang.graficoCrise30min + "         ",
            4: lang.graficoCrise1hora + "          ",
            5: lang.graficoCrise6horas + "     ",
            6: lang.graficoCrise12horas + "   "
        };
        for (let i in registrosBase) {
            for (let e in registrosBase[i].answers) {
                if (registrosBase[i].answers[e].id === 6 && registrosBase[i].answers[e].option !== 83) {
                    let tempo = registrosBase[i].answers[e].answerlabel.trim();
                    if (typeof referenciaN[tempo] === "number")
                        registros.push({date: registrosBase[i].created, tempo: referenciaN[tempo]})
                }
            }
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("date");
        grafico.setFieldX("date");
        grafico.setFieldY("tempo");
        grafico.setOptions({aspectRatio: 7});
        grafico.setOperacaoMedia();
        grafico.setHideLineX();
        grafico.setTitle(lang.tempoRecuperacao);
        grafico.setColorBase("#F0C773");
        grafico.setStepY(1);
        grafico.setRoundValueStepY();

        grafico.setFunctionLabelY(y => {
            return referencia[y]
        });

        grafico.setFunctionTooltips((x, y) => {
            if (y === 2)
                return "Imediatamente";
            return referencia[y]
        });

        grafico.setPaddings({left: 0, right: 20, bottom: 0, top: 20});
        $content.append('<div class="col" style="min-width: 790px;"><h4 class="font-medium font-bold margin-0 padding-0" id="grafico-header-title-recuperacao">' + lang.tempoRecuperacao + '</h4></div>');
        $content.append(grafico.getChart());

        return $content
    }

    /**
     * Gráfico de Sono
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoSono(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        for (let i in registrosBase) {
            if(modChart['sono'] !== 2 || registrosBase[i].duration > 0) {}
            if (typeof registrosBase[i].duration === "string" && registrosBase[i].duration !== "") {
                let p = registrosBase[i].duration.split(":");
                if (typeof p[1] !== "undefined" && !isNaN(p[0]) && !isNaN(p[1]))
                    registrosBase[i].duration = parseFloat(parseFloat(p[0] + "." + ((p[1] * 100) / 60)).toFixed(2)); else registrosBase[i].duration = parseFloat(registrosBase[i].duration)
            } else {
                registrosBase[i].duration = parseFloat(0)
            }

            /**
             * Adiciona a lista caso seja gráfico 1 ou 3, ou então se a duração for maior que 0
             */
            if(modChart['sono'] !== 2 || registrosBase[i].duration > 0)
                registros.push(registrosBase[i])
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("date");
        grafico.setFieldX("date");
        grafico.setHideLineX();
        grafico.setOptions({aspectRatio: 4});

        if (modChart.sono === 1) {

            /**
             * Gráfico de Sono 1
             */

            grafico.setTitle(getTitleIndicador("sono"));
            grafico.setMaxY(2.5);
            grafico.setMinY(-2.5);
            grafico.setFieldY("quality");
            grafico.setStepY(2.5);
            grafico.setOperacaoMaioria();

            grafico.setFunctionColor(function (color) {
                if (color < 0)
                    return "#BF0811";
                return '#2D92CB'
            });

            grafico.setFunctionLabelY(function (title) {
                if (title < 0)
                    return "Ruim            ";
                else if (title > 0)
                    return 'Bom             ';
                return ""
            });

            grafico.setFunctionTooltips(function (x, y) {
                if (y < 0)
                    return "Ruim";
                else if (y > 0)
                    return 'Bom';
                return ""
            });

            grafico.setFunctionValueY(function (y) {
                if (y === 0 || isEmpty(y))
                    return null;
                return y - 7.5
            });

            /**
             * Adiciona a seta para próximo gráfico
             */
            $content.append(Mustache.render(tpl.graficoArrowForward, {indicador: 'sono', mod: 2}));

            $content.append(grafico.getChart("bar"));

        } else if (modChart.sono === 2) {

            /**
             * Gráfico de Sono 2
             */

            if(chartFilter.interval === "year")
                grafico.setOperacaoMedia();
            else
                grafico.setOperacaoSoma();

            grafico.setFunctionColor(function (color) {
                // if (color < 6)
                //     return "#BF0811";
                // else if (color > 7)
                    return '#2D92CB';
                // return '#606060'
            });

            grafico.setFunctionLabelY(function (y) {
                return y + "h" + (y >= 10 ? "              " : "                ");
            });

            grafico.setFunctionTooltips(function (x, y) {
                return zeroEsquerda(Math.floor(y)) + ":" + zeroEsquerda(Math.round(y % 1 * 60)) + " hr"
            });

            grafico.setMinY(0);
            grafico.setFieldY("duration");
            let media = 0;

            /**
             * Obtém dados para calcular a média
             * @type {*}
             */
            let data = grafico.getData();
            let total = 0;
            for (let i in data) {
                if(data[i].y > 0) {
                    media += (!isNaN(data[i].y) ? parseFloat(data[i].y) : 0)
                    total++;
                }
            }

            media = parseFloat(parseFloat(media / total).toFixed(1));
            if (!isNaN(media))
                media = zeroEsquerda(Math.floor(media)) + ":" + zeroEsquerda(Math.round(media % 1 * 60));
            else
                media = 0;

            /**
             * Adiciona a seta para o gráfico anterior
             */
            $content.append(Mustache.render(tpl.graficoArrowBack, {indicador: 'sono', mod: 1}));
            /**
             * Adiciona a seta para próximo gráfico
             */
            $content.append(Mustache.render(tpl.graficoArrowForward, {indicador: 'sono', mod: 3}));

            /**
             * Gera o gráfico
             */
            $content.append(grafico.getChart("bar"));

            /**
             * Altera o título do gráfico com a média encontrada
             */
            setTimeout(function () {
                $("#grafico-header-title-sono").html(Mustache.render(tpl.graficoHeaderSubtitle, {title: lang.relTitleSono, valor: media, descricao: lang.descricaoSono}));
            }, 1);

        } else {

            /**
             * Gráfico de Sono 3
             */
            grafico.setOperacaoMaioria();
            grafico.setFieldY("quality");
            let data = grafico.getData();
            let bom = 0;
            let total = 0;

            for (let i in data) {
                if(!isEmpty(data[i].y)) {
                    total++;
                    if (data[i].y === "10")
                        bom++
                }
            }

            let graficoSono = {media: parseInt((bom * 100) / total)};
            if (!isNaN(graficoSono.media)) {
                graficoSono.rotate = (graficoSono.media > 85 ? "rotateGood" : (graficoSono.media > 65 ? "rotateNormal" : "rotateBad"));
                graficoSono.deg = (graficoSono.media > 85 ? "400" : (graficoSono.media > 65 ? "360" : "310"));
                graficoSono.color = (graficoSono.media > 85 ? "#83E4FD" : (graficoSono.media > 65 ? "#6a96b9" : "#BF0811"))
            } else {
                graficoSono.media = "";
                graficoSono.rotate = "rotateBad";
                graficoSono.deg = "310";
                graficoSono.color = "#6a96b9"
            }

            grafico.setTitle(getTitleIndicador("sono"));

            /**
             * Verifica se precisa adicionar a seta para o gráfico anterior
             */
            $content.append(Mustache.render(tpl.graficoArrowBack, {indicador: 'sono', mod: 2}));
            $content.append(Mustache.render(tpl.graficoSono, Object.assign(graficoSono, lang)))
        }
        return $content
    }

    function isInFilterDate(date) {
        return ((!isEmpty(chartFilter.dateStart) && chartFilter.dateStart !== "NaN-aN-aN" && date >= chartFilter.dateStart) && (!isEmpty(chartFilter.dateEnd) && chartFilter.dateEnd !== "NaN-aN-aN" && date <= chartFilter.dateEnd));
    }

    /**
     * Gráfico de Humor
     * @param registrosBase
     * @returns {jQuery|HTMLElement}
     */
    function graficoHumor(registrosBase) {

        /**
         * Ajusta os valores de registros passado para atender as necessidades do gráfico
         */
        let registros = [];
        let start = new Date(chartFilter.dateStart + " 00:00:00");
        let end = new Date(chartFilter.dateEnd + " 23:59:59");

        for (let i in registrosBase) {
            if (isInFilterDate(registrosBase[i].date) && registrosBase[i].mood_type > 0)
                registros.push(registrosBase[i])
        }

        /**
         * Inicializa o gráfico
         */
        let $content = $("<div></div>");
        let grafico = new ChartMaker();
        grafico.setData(registros);
        grafico.setFieldDate("date");
        grafico.setFieldY("mood_type");
        grafico.setMinY(0);
        grafico.setMaxY(5);
        grafico.setStepY(1);
        grafico.setRoundValueStepY();
        grafico.setHideLineX();
        grafico.setHideLabelY();
        grafico.setOperacaoMedia();
        grafico.setOptions({aspectRatio: 3.5});
        grafico.setTitle(getTitleIndicador("humor"));
        grafico.setColorBase("#C03A4C");

        grafico.setFunctionTooltips(function (x, y) {
            y = typeof y === "undefined" && typeof x !== "undefined" ? x : y;
            if (y < 1)
                return "Irritado"; else if (y < 2)
                return 'Triste'; else if (y < 3)
                return 'Neutro'; else if (y < 4)
                return 'Bem';
            return 'Feliz'
        });

        grafico.setFunctionLabelY(function (y) {
            if (y < 1)
                return "Irritado"; else if (y < 2)
                return 'Triste'; else if (y < 3)
                return 'Neutro'; else if (y < 4)
                return 'Bem';
            return 'Feliz'
        });

        grafico.setFunctionColor(function (color) {
            if (color < 1)
                return '#FF5159'; else if (color < 2)
                return "#6849B7"; else if (color < 3)
                return '#606060'; else if (color < 4)
                return '#2D92CB';
            return '#7EC8BD'
        });

        grafico.setFunctionValueY(function (y) {
            switch (y) {
                case 1:
                    return 4.5;
                case 2:
                    return 3.5;
                case 3:
                    return 2.5;
                case 4:
                    return 1.5;
                case 5:
                    return .5;
                default:
                    return null
            }
        });

        grafico.setPaddings({left: 88, right: 20, bottom: 10, top: 20});
        if (modChart.humor === 1) {

            /**
             * Gráfico de Humor 1
             */
            $content.append(Mustache.render(tpl.graficoHumor, lang));
            grafico.setFieldX("date");
            $content.append(grafico.getChart("scatter"))
        } else {

            /**
             * Gráfico de Humor 2
             */
            $content.append(Mustache.render(tpl.graficoHumor2, lang));
            $content.append(grafico.getChart("pie"))
        }

        return $content
    }

    /**
     * Função para gerar o Gráfico com base no indicador
     * @param indicador
     * @param registros
     * @param mod
     * @returns {jQuery|HTMLElement}
     */
    function grafico(indicador, registros, mod) {

        if (typeof mod === "undefined" && typeof modChart[indicador] === "undefined")
            modChart[indicador] = 1;
        else if (typeof mod !== "undefined")
            modChart[indicador] = mod;

        switch (indicador) {
            case 'humor':
                return graficoHumor(registros);
                break;
            case 'sono':
                return graficoSono(registros);
                break;
            case 'crises':
                return graficoCrises(registros);
                break;
            case 'atividade-fisica':
                return graficoAtividade(registros);
                break;
            case 'medicamentos':
                return graficoMedicamentos(registros);
                break;
            case 'sintomas':
                return graficoSintomas(registros);
                break
        }
    }

    /**
     * Gera o título dos gráficos
     * @param indicador
     * @returns {*|{}|undefined|void}
     */
    function graficoHeader(indicador) {
        let startDate = {day: '', month: '', year: ''};
        let endDate = {day: '', month: '', year: ''};
        let content = "";

        if (haveDate = chartFilter.dateStart && chartFilter.dateEnd) {
            startDate = chartFilter.dateStart.split("-");
            startDate = {day: startDate[2], month: startDate[1], year: startDate[0]};
            endDate = chartFilter.dateEnd.split("-");
            endDate = {day: endDate[2], month: endDate[1], year: endDate[0]}
        }

        /**
         * Caso específico para crises, adiciona as 3 imagens indicadoras de nível
         */
        if (indicador === "crises") {
            content = "<div class='left padding-small'>" + lang.criseFraca + "</div><img src='public/assets/img/graficos/nivel1.png' class='left padding-right' style='width:45px' />";
            content += "<div class='left padding-small'>" + lang.criseMedia + "</div><img src='public/assets/img/graficos/nivel2.png' class='left padding-right' style='width:45px' />";
            content += "<div class='left padding-small'>" + lang.criseForte + "</div><img src='public/assets/img/graficos/nivel3.png' class='left padding-right' style='width:45px' />"
        }

        return Mustache.render(tpl.graficoHeader, Object.assign({
            title: getTitleIndicador(indicador),
            indicador: indicador,
            indicadorTitle: lang['indicador' + ucFirst(indicador)].replace("-", " ").replace("_", " "),
            startDate: startDate,
            endDate: endDate,
            haveDate: haveDate,
            content: content
        }, lang))
    }

    /**
     * Obtém o título apropriado para cada indicador
     * @param indicador
     * @returns {string}
     */
    function getTitleIndicador(indicador) {
        if (indicador === "atividade-fisica") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1)
                return lang.calorias;
            else if (modChart[indicador] === 2)
                return lang.degraus;
            else if (modChart[indicador] === 3)
                return lang.metros;
            else if (modChart[indicador] === 4)
                return lang.minutos;
            else if (modChart[indicador] === 5)
                return lang.passos;

        } else if (indicador === "medicamentos") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1) {
                return lang.regMedicamentos;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 2) {
                return lang.medMedicamentos;
            }

        } else if (indicador === "humor") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1) {
                return lang.regHumor;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 2) {
                return lang.medHumor;
            }

        } else if (indicador === "sono") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1) {
                return lang.qualidadeSono;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 2) {
                return lang.horasSono;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 3) {
                return lang.qualidadeSono;
            }

        } else if (indicador === "crises") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1) {
                return lang.periodoCrises;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 2) {
                return lang.calendarioCrises;
            }
        } else if (indicador === "sintomas") {
            if (typeof modChart[indicador] === "undefined" || modChart[indicador] === 1) {
                return lang.regSintomas;
            } else if (typeof modChart[indicador] !== "undefined" && modChart[indicador] === 2) {
                return lang.relSintomas;
            }
        }

        return indicador.replace("-", " ").replace("_", " ");
    }

    var action = {
        "atividade-fisica": "activity",
        "crises": "seizure",
        "humor": "mood",
        "medicamentos": "medicine",
        "sintomas": "symptoms",
        "sono": "sleep"
    };

    /**
     * Mostra o gráfico com base em um indicador parâmetro
     * @param ind
     * @returns {Promise<[any, any][]>}
     */
    function graficos(ind) {
        return Promise.all([all]).then(() => {
            if (isEmpty(chartFilter.indicadores)) {
                /**
                 * Gráfico vazio
                 */
                $("#graficos").html(Mustache.render(tpl.pacienteGraficoEmpty, lang));

            } else {

                /**
                 * Indicador não informado retorna vazio
                 */
                if (typeof ind === "undefined")
                    $("#graficos").html("");

                /**
                 * Para cada gráficos selecionado, gera o gráfico
                 */
                $.each(chartFilter.indicadores, function (ii, indicador) {
                    if (!isEmpty(paciente) && (typeof ind === "undefined" || ind === indicador)) {
                        let $graficos = $("<div class='col relative' id='graficos-" + indicador + "'></div>").appendTo("#graficos");
                        $graficos.prepend(graficoHeader(indicador));
                        let minHeight = (window.innerWidth > 1300 ? 200 : (window.innerWidth > 1100 ? 217 : 150));
                        let $grafico = $("<div class='col relative' style='min-width: 800px; min-height: " + minHeight + "px' id='grafico-" + indicador + "'><div id='grafico-carregando'>Carregando registros...<img src='public/assets/img/grafico.png' style='max-width: 540px;float: initial;margin: auto;display: block;' width='540' class='col' alt='gráfico'></div></div>").appendTo($graficos);
                        $graficos.append("<div class='col padding-16'></div></div>");

                        /**
                         * Carregando o gráfico
                         */
                        $grafico.loading();
                        let load = setInterval(function () {
                            $grafico.loading();
                        }, 2000);

                        /**
                         * Lê os dados locais armazenados para este indicador
                         */
                        dbLocal.exeRead(indicador).then(g => {
                            if (isEmpty(g) || typeof readIndicador[indicador] === "undefined") {

                                /**
                                 * Informa ao readIndicador qual o gráfico que esta sendo exibido
                                 * neste caso, o primeiro gráfico do indicador em questão
                                 */
                                readIndicador[indicador] = 1;

                                /**
                                 * Parâmetros para a API
                                 */
                                let data = {"patient_id": parseInt(paciente.id), "interval": "year", "intensity": 1};

                                if (indicador === "humor" || indicador === "crises" || indicador === "sono")
                                    data.patient_name = paciente.first_name;

                                /**
                                 * Envia a requisição a API para obter os dados do gráfico
                                 */
                                console.log(data);
                                apiPost(action[indicador], data).then(t => {
                                    if (t) {
                                        /**
                                         * Limpa os dados locais atuais para salvar os novos obtidos
                                         */
                                        dbLocal.clear(indicador).then(() => {

                                            /**
                                             * Cria os registros recebidos na base local para flexibilidade e performance
                                             */
                                            let creates = [];
                                            $.each(t, function (i, e) {
                                                if (typeof e.id === "undefined")
                                                    e.id = i;
                                                if (indicador === "sono") {
                                                    if (isEmpty(e.duration) && !isEmpty(e.start_time) && !isEmpty(e.end_time)) {
                                                        let ss = e.start_time.split(":");
                                                        let ee = e.end_time.split(":");
                                                        let dayStart = moment(e.date + " " + e.start_time);
                                                        let dayEnd = (parseInt(ss[0]) < parseInt(ee[0]) ? dayStart : moment(moment(e.date).add(1, 'day').format("YYYY-MM-DD") + " " + e.end_time));
                                                        let duration = moment.duration(dayEnd.diff(dayStart));
                                                        e.duration = duration.asHours()
                                                    }
                                                }
                                                creates.push(dbLocal.exeCreate(indicador, e))
                                            });

                                            /**
                                             * Se a base local não tiver resultados e a requisição a API tiver
                                             * então exibe o gráfico com os dados da API
                                             */
                                            if (isEmpty(g)) {
                                                Promise.all(creates).then(() => {
                                                    clearInterval(load);
                                                    $grafico.html(grafico(indicador, t))
                                                })
                                            }
                                        })
                                    }
                                })
                            }

                            /**
                             * Se tiver dados locais, então exibe o gráfico com os dados
                             */
                            if (!isEmpty(g)) {
                                clearInterval(load);
                                $grafico.html(grafico(indicador, g));
                            }
                        })
                    }
                })
            }
        })
    }

    /**
     * Atualiza os limites (data) que o gráfico pode exibir, limitando as datas que podem ser selecionadas
     * NÃO APLICADO / DESCONTINUADO (mantém a seleção de datas livre)
     *
     * @param useStartDateInsteadDateEnd
     * @param ignoraControleManual
     */
    function privateChartDateUpdateLimit(useStartDateInsteadDateEnd) {
        useStartDateInsteadDateEnd = typeof useStartDateInsteadDateEnd !== "undefined";
        let now = new Date((useStartDateInsteadDateEnd ? chartFilter.dateStart : chartFilter.dateEnd) + " 23:59:59");
        let limit = (chartFilter.interval === "year" ? 364 : (chartFilter.interval === "month" ? privateChartGetNumberDaysMonth(now.getMonth()) - 1 : (chartFilter.interval === "week" ? 6 : 0)));

        if (useStartDateInsteadDateEnd) {
            let dateLimit = new Date(now.setDate(now.getDate() + limit));
            chartFilter.dateEnd = dateLimit.getFullYear() + "-" + zeroEsquerda(dateLimit.getMonth() + 1) + "-" + zeroEsquerda(dateLimit.getDate());
            $("#date-end").val(chartFilter.dateEnd)

        } else {

            let dateLimit = new Date(now.setDate(now.getDate() - limit));
            chartFilter.dateStart = dateLimit.getFullYear() + "-" + zeroEsquerda(dateLimit.getMonth() + 1) + "-" + zeroEsquerda(dateLimit.getDate());
            $("#date-start").val(chartFilter.dateStart)

            chartFilter.dateEnd = moment(chartFilter.dateStart).add(limit, 'days').format("YYYY-MM-DD");
            $("#date-end").val(chartFilter.dateEnd)
        }
    }

    $(function () {

        /**
         * Lê as informações do paciente para exibir o seu perfil
         */
        readPaciente(ID).then(paciente => {
            if (!isEmpty(paciente)) {
                getJSON('public/language/' + LANG + '/cardPaciente.json').then(lang => {
                    getRequest('public/tpl/pacientePerfil.mustache').then(tpl => {
                        $("#paciente-info").html(Mustache.render(tpl, Object.assign({}, lang, paciente)))
                    })
                })
            }
        });

        /**
         * Ao trocar a data, faz a geração dos gráficos novamente
         */
        $("#date-start").off("change").on("change", function () {
            chartFilter.dateStart = $(this).val();
            privateChartDateUpdateLimit(1);
            graficos()
        });
        $("#date-end").off("change").on("change", function () {
            chartFilter.dateEnd = $(this).val();
            privateChartDateUpdateLimit();
            graficos()
        });

        /**
         * Ação para o clique na seleção do tempo (dia, semana, mes, ano)
         */
        $(".time-week").off("click").on("click", function () {
            $(".time-week").removeClass("active");
            $(this).addClass("active");
            chartFilter.interval = $(this).attr("rel");
            privateChartDateUpdateLimit(1);
            graficos()
        });

        /**
         * Ação para o clique nos indicadores
         */
        $(".indicador").off("click").on("click", function () {
            if (chartFilter.indicadores.length === 0)
                $("#graficos").html("");
            let v = $(this).attr("rel");
            if (chartFilter.indicadores.indexOf(v) > -1) {
                removeItemArray(chartFilter.indicadores, v);
                $(this).removeClass("active");
                $("#graficos-" + v).remove();
                if (chartFilter.indicadores.length === 0)
                    $("#graficos").html(Mustache.render(tpl.pacienteGraficoEmpty, lang))
            } else {
                chartFilter.indicadores.push(v);
                $(this).addClass("active");
                graficos(v)
            }
        });

        /**
         * Dispara função ao clicar para ir ao gráfico anterior
         */
        $("#app").off("click", ".graficoArrow").on("click", ".graficoArrow", function () {
            let indicador = $(this).attr("rel");
            let mod = parseInt($(this).attr("data-mod"));
            let $g = $("#grafico-" + indicador);
            $g.css({"height": $g[0].clientHeight + "px"});
            dbLocal.exeRead(indicador).then(g => {
                $g.html(grafico(indicador, g, mod));
                $("#grafico-header-title-" + indicador).html(getTitleIndicador(indicador));
                setTimeout(function () {
                    $g.css({"height": "auto"})
                }, 200)
            })

            /**
             * Abre os comentários da crise
             */
        }).off("click", ".comment-crise").on("click", ".comment-crise", function () {
            lightbox($(this).attr("rel"))
        });

        /**
         * Régua para orientação
         */
        $("#linevertical").off("mousedown").on("mousedown", function () {
            $(document).on("mousemove", function (event) {
                let left = event.pageX - (window.innerWidth > 990 ? $("#paciente-pefil-filtro").innerWidth() + (window.innerWidth > 1400 ? ((window.innerWidth - 1400) / 2) : 0) : 0);
                left = left > 900 ? 900 : (left < 8 ? 8 : left);
                if (left < 10 || left > 898)
                    $("#linevertical").addClass("active"); else $("#linevertical").removeClass("active");
                $("#linevertical").css("left", left + "px")
            }).one('mouseup', function () {
                $(document).off("mousemove")
            })
        });

        /**
         * Definição inicial para o calendário
         * padrão ultimos 30 dias
         */
        startCalendar();

        /**
         * Chama a função para gerar os gráficos
         */
        graficos();

        /**
         * Adiciona Ajustes à página
         */
        getJSON('public/language/' + LANG + '/ajustes.json').then(lang => {
            getRequest('public/tpl/ajustes.mustache').then(tpl => {
                $(".paciente").append(Mustache.render(tpl, lang))
            })
        });

        if ($(window).width() > 990)
            $("#grafico-board").css("max-height", ($(window).height() - 130) + "px");
        else
            $("#grafico-board").css("max-height", ($(window).height() - 170) + "px");

        setTimeout(function () {
            $("#date-start").val("2019-10-23").trigger("change");
        },1);
    })
}